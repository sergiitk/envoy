syntax = "proto3";

package envoy.service.rate_limit_quota.v3;

import "envoy/type/v3/ratelimit_strategy.proto";

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";

import "xds/annotations/v3/status.proto";

import "udpa/annotations/status.proto";
import "validate/validate.proto";

option java_package = "io.envoyproxy.envoy.service.rate_limit_quota.v3";
option java_outer_classname = "RlqsProto";
option java_multiple_files = true;
option go_package = "github.com/envoyproxy/go-control-plane/envoy/service/rate_limit_quota/v3;rate_limit_quotav3";
option java_generic_services = true;
option (udpa.annotations.file_status).package_version_status = ACTIVE;
option (xds.annotations.v3.file_status).work_in_progress = true;

// [#not-implemented-hide:]
// [#protodoc-title: Rate Limit Quota Service (RLQS)]

service RateLimitQuotaService {
  rpc StreamRateLimitQuotas(stream RateLimitQuotaUsageReports)
      returns (stream RateLimitQuotaAssignments) {
  }
}

message RateLimitQuotaUsageReports {
  // [#next-free-field: 7]
  message BucketQuotaUsage {
    // Bucket id for which request quota usage is reported.
    BucketId bucket_id = 1 [(validate.rules).message = {required: true}];

    // Auto-incrementing number used to deduplicate usage reports.
    uint64 report_id = 2;

    // Time elapsed since the last report.
    google.protobuf.Duration time_elapsed = 3;

    // Requests the data plane has allowed through.
    uint64 num_requests_allowed = 4;

    // Requests throttled.
    uint64 num_requests_denied = 5;

    // Requests in the queue waiting for the assignment.
    uint64 num_requests_queued = 6;
  }

  // All quota requests must specify the domain. This enables sharing the quota
  // server between different applications without fear of overlap.
  // E.g., "envoy".
  // [#comment:TODO(sergiitk): add a note about domain being optional after the first report]
  // [#comment:TODO(sergiitk): add a note about closing a stream on domain change.]
  string domain = 1;

  // A list of quota usage reports for each bucket.
  repeated BucketQuotaUsage bucket_quota_usages = 2 [(validate.rules).repeated = {min_items: 1}];
}

message RateLimitQuotaAssignments {
  message QuotaAssignment {
    // Bucket id for which this quota is granted.
    BucketId bucket_id = 1 [(validate.rules).message = {required: true}];

    // A duration after which the assignment should be considered expired if it
    // hasn't received a new value.
    // If unset, the assignment has no expiration date.
    google.protobuf.Duration assignment_time_to_live = 2;

    // Rate limiter strategy determines the implementation details for when to
    // allow and deny the requests matched to the bucket.
    // If unset, no limit.
    type.v3.RateLimitStrategy rate_limit_strategy = 3;
  }

  // An ordered list of assignments to be applied to the quota buckets.
  // When the quota is different from bucket's active assignment,
  // the data plane must immediately end the assignment, and
  // report the usage.
  repeated QuotaAssignment quota_assignment = 1;
}

// The identifier for the bucket. Used to match the bucket on the control
// plane (RLQS server), and on the data plane (RLQS client).
message BucketId {
  map<string, string> bucket = 1;
}
